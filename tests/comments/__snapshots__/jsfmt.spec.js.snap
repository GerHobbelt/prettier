// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`assignment-pattern.js - flow-verify: assignment-pattern.js 1`] = `
const { a /* comment */ = 1 } = b;

const { c = 1 /* comment */ } = d;

let {a //comment
= b} = c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const { a /* comment */ = 1 } = b;

const { c = 1 /* comment */ } = d;

let {
  a = b //comment
} = c;

`;

exports[`before-comma.js - flow-verify: before-comma.js 1`] = `
const foo = {
  a: 'a' /* comment for this line */,

  /* Section B */
  b: 'b',
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const foo = {
  a: "a" /* comment for this line */,

  /* Section B */
  b: "b"
};

`;

exports[`blank.js - flow-verify: blank.js 1`] = `
// This file only
// has comments. This comment
// should still exist
//
// when printed.

/**
 * @typedef {DataDrivenMapping|ConstantMapping} Mapping
 */
/**
 * @typedef {Object.<String, Mapping>} ConfigurationMapping
 */

/**
 * @typedef {Function} D3Scale - a D3 scale
 * @property {Function} ticks
 * @property {Function} tickFormat
 */
// comment

// comment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// This file only
// has comments. This comment
// should still exist
//
// when printed.

/**
 * @typedef {DataDrivenMapping|ConstantMapping} Mapping
 */
/**
 * @typedef {Object.<String, Mapping>} ConfigurationMapping
 */

/**
 * @typedef {Function} D3Scale - a D3 scale
 * @property {Function} ticks
 * @property {Function} tickFormat
 */
// comment

// comment

`;

exports[`break-continue-statements.js - flow-verify: break-continue-statements.js 1`] = `
for (;;) {
  break /* comment */;
  continue /* comment */;
}

loop: for (;;) {
  break /* comment */ loop;
  break loop /* comment */;
  continue /* comment */ loop;
  continue loop /* comment */;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
for (;;) {
  break; /* comment */
  continue; /* comment */
}

loop: for (;;) {
  break /* comment */ loop;
  break loop /* comment */;
  continue /* comment */ loop;
  continue loop /* comment */;
}

`;

exports[`call_comment.js - flow-verify: call_comment.js 1`] = `
render( // Warm any cache
  <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
  container
);

React.render( // Warm any cache
  <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
  container
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
render(
  // Warm any cache
  <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
  container
);

React.render(
  // Warm any cache
  <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
  container
);

`;

exports[`closure-compiler-type-cast.js - flow-verify: closure-compiler-type-cast.js 1`] = `
// test to make sure comments are attached correctly
let inlineComment = /* some comment */ (
  someReallyLongFunctionCall(withLots, ofArguments));

let object = {
  key: /* some comment */ (someReallyLongFunctionCall(withLots, ofArguments))
};

// preserve parens only for type casts
let assignment = /** @type {string} */ (getValue());

functionCall(1 + /** @type {string} */ (value), /** @type {!Foo} */ ({}));

function returnValue() {
  return /** @type {!Array.<string>} */ (['hello', 'you']);
}

var newArray = /** @type {array} */ (numberOrString).map(x => x);
var newArray = /** @type {array} */ ((numberOrString)).map(x => x);
var newArray = /** @type {array} */ ((numberOrString).map(x => x));
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// test to make sure comments are attached correctly
let inlineComment = /* some comment */ someReallyLongFunctionCall(
  withLots,
  ofArguments
);

let object = {
  key: /* some comment */ someReallyLongFunctionCall(withLots, ofArguments)
};

// preserve parens only for type casts
let assignment = /** @type {string} */ (getValue());

functionCall(1 + /** @type {string} */ (value), /** @type {!Foo} */ ({}));

function returnValue() {
  return /** @type {!Array.<string>} */ (["hello", "you"]);
}

var newArray = /** @type {array} */ (numberOrString).map(x => x);
var newArray = /** @type {array} */ (numberOrString).map(x => x);
var newArray = /** @type {array} */ (numberOrString.map(x => x));

`;

exports[`dangling.js - flow-verify: dangling.js 1`] = `
var x = {/* dangling */};
var x = {
  // dangling
};
var x = [/* dangling */];
function x() {
  /* dangling */
}
declare class Foo extends Qux<string> {/* dangling */}
export /* dangling */{};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
var x = {
  /* dangling */
};
var x = {
  // dangling
};
var x = [
  /* dangling */
];
function x() {
  /* dangling */
}
declare class Foo extends Qux<string> {
  /* dangling */
}
export /* dangling */{};

`;

exports[`dangling_array.js - flow-verify: dangling_array.js 1`] = `
expect(() => {}).toTriggerReadyStateChanges([
  // Nothing.
]);

[1 /* first comment */, 2 /* second comment */, 3];
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expect(() => {}).toTriggerReadyStateChanges([
  // Nothing.
]);

[1 /* first comment */, 2 /* second comment */, 3];

`;

exports[`dangling_for.js - flow-verify: dangling_for.js 1`] = `
for // comment
(;;);

for /* comment */(;;);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// comment
for (;;);

/* comment */
for (;;);

`;

exports[`dangling_object.js - flow-verify: dangling_object.js 1`] = `
// Full-featured Lexer Run-Time Class core (to be included in every generated lexer)
let lexer = {
    EOF: 1,
    ERROR: 2,

    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

    // options: {},                             /// <-- injected by the code generator

    // yy: ...,                                 /// <-- injected by setInput()

    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state

    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup

    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use

    done: false,                                /// INTERNAL USE ONLY
    _backtrack: false,                          /// INTERNAL USE ONLY
    _input: '',                                 /// INTERNAL USE ONLY
    _more: false,                               /// INTERNAL USE ONLY
    _signaled_error_token: false,               /// INTERNAL USE ONLY
    _clear_state: 0,                            /// INTERNAL USE ONLY; 0: clear to do, 1: clear done for lex()/next(); -1: clear done for inut()/unput()/...

    conditionStack: [],                         /// INTERNAL USE ONLY; managed via \`pushState()\`, \`popState()\`, \`topState()\` and \`stateStackSize()\`

    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. \`match\` is identical to \`yytext\` except that this one still contains the matched input string after \`lexer.performAction()\` has been invoked, where userland code MAY have changed/replaced the \`yytext\` value entirely!
    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far
    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt
    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the \`lex()\` API.
    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far. (**WARNING:** this value MAY be negative if you \`unput()\` more text than you have already lexed. This type of behaviour is generally observed for one kind of 'lexer/parser hack' where custom token-illiciting characters are pushed in front of the input stream to help simulate multiple-START-points in the parser. When this happens, \`base_position\` will be adjusted to help track the original input's starting point in the \`_input\` buffer.)
    base_position: 0,                           /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: index to the original starting point of the input; always ZERO(0) unless \`unput()\` has pushed content before the input: see the \`offset\` **WARNING** just above.
    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (\`yytext\`)
    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located
    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction
    CRLF_Re: /\\r\\n?|\\n/,                        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: regex used to split lines while tracking the lexer cursor position.
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Full-featured Lexer Run-Time Class core (to be included in every generated lexer)
let lexer = {
  EOF: 1,
  ERROR: 2,

  // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator

  // options: {},                             /// <-- injected by the code generator

  // yy: ...,                                 /// <-- injected by setInput()

  __currentRuleSet__: null, /// INTERNAL USE ONLY: internal rule set cache for the current lexer state

  __error_infos: [], /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup

  __decompressed: false, /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use

  done: false, /// INTERNAL USE ONLY
  _backtrack: false, /// INTERNAL USE ONLY
  _input: "", /// INTERNAL USE ONLY
  _more: false, /// INTERNAL USE ONLY
  _signaled_error_token: false, /// INTERNAL USE ONLY
  _clear_state: 0, /// INTERNAL USE ONLY; 0: clear to do, 1: clear done for lex()/next(); -1: clear done for inut()/unput()/...

  conditionStack: [], /// INTERNAL USE ONLY; managed via \`pushState()\`, \`popState()\`, \`topState()\` and \`stateStackSize()\`

  match: "", /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. \`match\` is identical to \`yytext\` except that this one still contains the matched input string after \`lexer.performAction()\` has been invoked, where userland code MAY have changed/replaced the \`yytext\` value entirely!
  matched: "", /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far
  matches: false, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt
  yytext: "", /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the \`lex()\` API.
  offset: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far. (**WARNING:** this value MAY be negative if you \`unput()\` more text than you have already lexed. This type of behaviour is generally observed for one kind of 'lexer/parser hack' where custom token-illiciting characters are pushed in front of the input stream to help simulate multiple-START-points in the parser. When this happens, \`base_position\` will be adjusted to help track the original input's starting point in the \`_input\` buffer.)
  base_position: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: index to the original starting point of the input; always ZERO(0) unless \`unput()\` has pushed content before the input: see the \`offset\` **WARNING** just above.
  yyleng: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (\`yytext\`)
  yylineno: 0, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located
  yylloc: null, /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction
  CRLF_Re: /\\r\\n?|\\n/ /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: regex used to split lines while tracking the lexer cursor position.
};

`;

exports[`dynamic_imports.js - flow-verify: dynamic_imports.js 1`] = `
import(/* Hello */ 'something')

import('something' /* Hello */)

import(/* Hello */ 'something' /* Hello */)

import('something' /* Hello */ + 'else')
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import(/* Hello */ "something");

import("something" /* Hello */);

import(/* Hello */ "something" /* Hello */);

import("something" /* Hello */ + "else");

`;

exports[`export.js - flow-verify: export.js 1`] = `
export //comment
{}

export /* comment */ {};

export {
  foo // comment
}

export {
  // comment
  bar
}

export {
  fooo, // comment
  barr, // comment
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
export //comment
{};

export /* comment */{};

export {
  foo // comment
};

export {
  // comment
  bar
};

export {
  fooo, // comment
  barr // comment
};

`;

exports[`first-line.js - flow-verify: first-line.js 1`] = `
a // comment
b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
a; // comment
b;

`;

exports[`flow_union.js - flow-verify: flow_union.js 1`] = `
type UploadState<E, EM, D>
  // The upload hasnt begun yet
  = {type: "Not_begun"}
  // The upload timed out
  | {type: "Timed_out"}
  // Failed somewhere on the line
  | {type: "Failed", error: E, errorMsg: EM}
  // Uploading to aws3 and CreatePostMutation succeeded
  | {type: "Success", data: D};

type UploadState<E, EM, D>
  // The upload hasnt begun yet
  = A
  // The upload timed out
  | B
  // Failed somewhere on the line
  | C
  // Uploading to aws3 and CreatePostMutation succeeded
  | D;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type UploadState<E, EM, D> =
  // The upload hasnt begun yet
  | { type: "Not_begun" }
  // The upload timed out
  | { type: "Timed_out" }
  // Failed somewhere on the line
  | { type: "Failed", error: E, errorMsg: EM }
  // Uploading to aws3 and CreatePostMutation succeeded
  | { type: "Success", data: D };

type UploadState<E, EM, D> =
  // The upload hasnt begun yet
  | A
  // The upload timed out
  | B
  // Failed somewhere on the line
  | C
  // Uploading to aws3 and CreatePostMutation succeeded
  | D;

`;

exports[`function-declaration.js - flow-verify: function-declaration.js 1`] = `
function a(/* comment */) {} // comment
function b() {} // comment
function c(/* comment */ argA, argB, argC) {} // comment
call((/*object*/ row) => {});
KEYPAD_NUMBERS.map(num => ( // Buttons 0-9
  <div />
));

function f /* f */() {}
function f (/* args */) {}
function f () /* returns */ {}
function f /* f */(/* args */) /* returns */ {}

function f /* f */(/* a */ a) {}
function f /* f */(a /* a */) {}
function f /* f */(/* a */ a) /* returns */ {}

const obj = {
  f1 /* f */() {},
  f2 (/* args */) {},
  f3 () /* returns */ {},
  f4 /* f */(/* args */) /* returns */ {},
};

(function f /* f */() {})();
(function f (/* args */) {})();
(function f () /* returns */ {})();
(function f /* f */(/* args */) /* returns */ {})();

class C {
  f/* f */() {}
}
class C {
  f(/* args */) {}
}
class C {
  f() /* returns */ {}
}
class C {
  f/* f */(/* args */) /* returns */ {}
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function a(/* comment */) {} // comment
function b() {} // comment
function c(/* comment */ argA, argB, argC) {} // comment
call((/*object*/ row) => {});
KEYPAD_NUMBERS.map((
  num // Buttons 0-9
) => <div />);

function f /* f */() {}
function f(/* args */) {}
function f() /* returns */ {}
function f /* f */(/* args */) /* returns */ {}

function f /* f */(/* a */ a) {}
function f /* f */(a /* a */) {}
function f /* f */(/* a */ a) /* returns */ {}

const obj = {
  f1 /* f */() {},
  f2(/* args */) {},
  f3() /* returns */ {},
  f4 /* f */(/* args */) /* returns */ {}
};

(function f /* f */() {})();
(function f(/* args */) {})();
(function f() /* returns */ {})();
(function f /* f */(/* args */) /* returns */ {})();

class C {
  f /* f */() {}
}
class C {
  f(/* args */) {}
}
class C {
  f() /* returns */ {}
}
class C {
  f /* f */(/* args */) /* returns */ {}
}

`;

exports[`if.js - flow-verify: if.js 1`] = `
if (1)
// comment
{
  false
}
// comment
else if (2)
  true
// multi
// ple
// lines
else if (3)
  // existing comment
  true
// okay?
else if (4) {
  // empty with existing comment
}
// comment
else {
}

if (1)
{}
else // comment
{}

if (5) // comment
true

if (6) // comment
{true}
else if (7) // comment
true
else // comment
{true}

if (8) // comment
// comment
{true}
else if (9) // comment
// comment
true
else // comment
// comment
{true}

if (10) /* comment */ // comment
{true}
else if (11) /* comment */
true
else if (12) // comment /* comment */ // comment
true
else if (13) /* comment */ /* comment */ // comment
true
else /* comment */
{true}

if (14) // comment
/* comment */
// comment
{true}
else if (15) // comment
/* comment */
/* comment */ // comment
true
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if (1) {
  // comment
  false;
}
// comment
else if (2) true;
// multi
// ple
// lines
else if (3)
  // existing comment
  true;
// okay?
else if (4) {
  // empty with existing comment
}
// comment
else {
}

if (1) {
} // comment
else {
}

if (1) {
} else {
  // comment
}

if (5)
  // comment
  true;

if (6) {
  // comment
  true;
} else if (7)
  // comment
  true;
// comment
else {
  true;
}

if (8) {
  // comment
  // comment
  true;
} else if (9)
  // comment
  // comment
  true;
// comment
// comment
else {
  true;
}

if (10) {
  /* comment */ // comment
  true;
} else if (11)
  /* comment */
  true;
else if (12)
  // comment /* comment */ // comment
  true;
else if (13)
  /* comment */ /* comment */ // comment
  true;
/* comment */ else {
  true;
}

if (14) {
  // comment
  /* comment */
  // comment
  true;
} else if (15)
  // comment
  /* comment */
  /* comment */ // comment
  true;

`;

exports[`issues.js - flow-verify: issues.js 1`] = `
// Does not need to break as it fits in 80 columns
this.call(a, /* comment */ b);

function f(
  someReallyLongArgument: WithSomeLongType,
  someReallyLongArgument2: WithSomeLongType,
  // Trailing comment should stay after
) {}

// Comments should either stay at the end of the line or always before, but
// not one before and one after.
throw new ProcessSystemError({
  code: acc.error.code, // Alias of errno
  originalError: acc.error, // Just in case.
});

// Adding a comment stops the pretty printing process and everything is
// squished in a single line afterward
export type BuckWebSocketMessage = {
  // Not actually from Buck - this is to let the receiver know that the socket is connected.
  type: 'SocketConnected',
} | {
  type: 'BuildProgressUpdated',
  progressValue: number,
} | {
  type: 'BuildFinished',
  exitCode: number,
} | {
  type: 'BuildStarted',
} | {
  type: 'ParseStarted',
} | {
  type: 'ParseFinished',
} | {
  type: 'RunStarted',
} | {
  type: 'RunComplete',
};

// Missing one level of indentation because of the comment
const rootEpic = (actions, store) => (
  combineEpics(...epics)(actions, store)
    // Log errors and continue.
    .catch((err, stream) => {
      getLogger().error(err);
      return stream;
    })
);

// Two extra levels of indentation because of the comment
export type AsyncExecuteOptions = child_process$execFileOpts & {
  // The contents to write to stdin.
  stdin?: ?string,
  dontLogInNuclide?: ?boolean,
};

// optional trailing comma gets moved all the way to the beginning
const regex = new RegExp(
  '^\\\\s*' + // beginning of the line
  'name\\\\s*=\\\\s*' + // name =
  '[\\'"]' + // opening quotation mark
  escapeStringRegExp(target.name) + // target name
  '[\\'"]' + // closing quotation mark
  ',?$', // optional trailing comma
);

// The comment is moved and doesn't trigger the eslint rule anymore
import path from 'path'; // eslint-disable-line nuclide-internal/prefer-nuclide-uri

// Comments disappear in-between MemberExpressions
Observable.of(process)
  // Don't complete until we say so!
  .merge(Observable.never())
  // Get the errors.
  .takeUntil(throwOnError ? errors.flatMap(Observable.throw) : errors)
  .takeUntil(exit);

// Comments disappear inside of JSX
<div>
  {/* Some comment */}
</div>;

// Comments in JSX tag are placed in a non optimal way
<div
  // comment
/>;

// Comments disappear in empty blocks
if (1) {
  // Comment
}

// Comments trigger invalid JavaScript in-between else if
if (1) {
}
// Comment
else {

}

// The comment makes the line break in a weird way
const result = asyncExecute('non_existing_command', /* args */ []);

// The closing paren is printed on the same line as the comment
foo({}
  // Hi
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Does not need to break as it fits in 80 columns
this.call(a, /* comment */ b);

function f(
  someReallyLongArgument: WithSomeLongType,
  someReallyLongArgument2: WithSomeLongType
  // Trailing comment should stay after
) {}

// Comments should either stay at the end of the line or always before, but
// not one before and one after.
throw new ProcessSystemError({
  code: acc.error.code, // Alias of errno
  originalError: acc.error // Just in case.
});

// Adding a comment stops the pretty printing process and everything is
// squished in a single line afterward
export type BuckWebSocketMessage =
  | {
      // Not actually from Buck - this is to let the receiver know that the socket is connected.
      type: "SocketConnected"
    }
  | {
      type: "BuildProgressUpdated",
      progressValue: number
    }
  | {
      type: "BuildFinished",
      exitCode: number
    }
  | {
      type: "BuildStarted"
    }
  | {
      type: "ParseStarted"
    }
  | {
      type: "ParseFinished"
    }
  | {
      type: "RunStarted"
    }
  | {
      type: "RunComplete"
    };

// Missing one level of indentation because of the comment
const rootEpic = (actions, store) =>
  combineEpics(...epics)(actions, store)
    // Log errors and continue.
    .catch((err, stream) => {
      getLogger().error(err);
      return stream;
    });

// Two extra levels of indentation because of the comment
export type AsyncExecuteOptions = child_process$execFileOpts & {
  // The contents to write to stdin.
  stdin?: ?string,
  dontLogInNuclide?: ?boolean
};

// optional trailing comma gets moved all the way to the beginning
const regex = new RegExp(
  "^\\\\s*" + // beginning of the line
  "name\\\\s*=\\\\s*" + // name =
  "['\\"]" + // opening quotation mark
  escapeStringRegExp(target.name) + // target name
  "['\\"]" + // closing quotation mark
    ",?$" // optional trailing comma
);

// The comment is moved and doesn't trigger the eslint rule anymore
import path from "path"; // eslint-disable-line nuclide-internal/prefer-nuclide-uri

// Comments disappear in-between MemberExpressions
Observable.of(process)
  // Don't complete until we say so!
  .merge(Observable.never())
  // Get the errors.
  .takeUntil(throwOnError ? errors.flatMap(Observable.throw) : errors)
  .takeUntil(exit);

// Comments disappear inside of JSX
<div>{/* Some comment */}</div>;

// Comments in JSX tag are placed in a non optimal way
<div
// comment
/>;

// Comments disappear in empty blocks
if (1) {
  // Comment
}

// Comments trigger invalid JavaScript in-between else if
if (1) {
}
// Comment
else {
}

// The comment makes the line break in a weird way
const result = asyncExecute("non_existing_command", /* args */ []);

// The closing paren is printed on the same line as the comment
foo(
  {}
  // Hi
);

`;

exports[`jsx.js - flow-verify: jsx.js 1`] = `
<div>
  {
    /* comment */
  }
</div>;

<div>
  {/* comment */
  }
</div>;

<div>
  {/* comment
*/
  }
</div>;

<div>
  {a/* comment
*/
  }
</div>;

<div>
  {/* comment
*/
  a
  }
</div>;

<div>
  {/* comment */
  }
</div>;

<div>
  {/* comment */}
</div>;

<div>
  {
    // single line comment
  }
</div>;

<div>
  {
    // multiple line comments 1
    // multiple line comments 2
  }
</div>;

<div>
  {
    // multiple mixed comments 1
    /* multiple mixed comments 2 */
    /* multiple mixed comments 3 */
    // multiple mixed comments 4
  }
</div>;

<div>
  {
    // Some very v  ery very very merry (xmas) very very long line to break line width limit
  }
</div>;

<div>{/*<div>  Some very v  ery very very long line to break line width limit </div>*/}</div>;

<div>
  {/**
   * JSDoc-y comment in JSX. I wonder what will happen to it?
  */}
</div>;

<div>
  {
    /**
   * Another JSDoc comment in JSX.
  */
  }
</div>;

<div
  /**
 * Handles clicks.
*/
onClick={() => {}}>

</div>;

<div
  // comment
>
  {foo}
</div>;

<div
  className="foo" // comment
>
  {foo}
</div>;

<div
  className="foo"
  // comment
>
  {foo}
</div>;

<div // comment
  id="foo"
>
  {children}
</div>;

<Wrapper>
  {}
  <Component />
</Wrapper>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<div>{/* comment */}</div>;

<div>{/* comment */}</div>;

<div>{/* comment
*/}</div>;

<div>{a /* comment
*/}</div>;

<div>
  {
    /* comment
*/
    a
  }
</div>;

<div>{/* comment */}</div>;

<div>{/* comment */}</div>;

<div>
  {
    // single line comment
  }
</div>;

<div>
  {
    // multiple line comments 1
    // multiple line comments 2
  }
</div>;

<div>
  {
    // multiple mixed comments 1
    /* multiple mixed comments 2 */
    /* multiple mixed comments 3 */
    // multiple mixed comments 4
  }
</div>;

<div>
  {
    // Some very v  ery very very merry (xmas) very very long line to break line width limit
  }
</div>;

<div>
  {/*<div>  Some very v  ery very very long line to break line width limit </div>*/}
</div>;

<div>
  {/**
   * JSDoc-y comment in JSX. I wonder what will happen to it?
   */}
</div>;

<div>
  {/**
   * Another JSDoc comment in JSX.
   */}
</div>;

<div
  /**
   * Handles clicks.
   */
  onClick={() => {}}
/>;

<div
// comment
>
  {foo}
</div>;

<div
  className="foo" // comment
>
  {foo}
</div>;

<div
  className="foo"
  // comment
>
  {foo}
</div>;

<div // comment
  id="foo"
>
  {children}
</div>;

<Wrapper>
  {}
  <Component />
</Wrapper>;

`;

exports[`last-arg.js - flow-verify: last-arg.js 1`] = `
type f = (
  currentRequest: {a: number},
  // TODO this is a very very very very long comment that makes it go > 80 columns
) => number;

f = (
  currentRequest: {a: number},
  // TODO this is a very very very very long comment that makes it go > 80 columns
): number => {};

f = (
  currentRequest: {a: number},
  // TODO this is a very very very very long comment that makes it go > 80 columns
) => {};

f = function(
  currentRequest: {a: number},
  // TODO this is a very very very very long comment that makes it go > 80 columns
) {};

class X {
  f(
    currentRequest: {a: number},
    // TODO this is a very very very very long comment that makes it go > 80 columns
  ) {}
}

function f(
  a: number
// some comment here
): number {
  return a + 1;
}

var x = {
  getSectionMode(
    pageMetaData: PageMetaData,
    sectionMetaData: SectionMetaData
    /* $FlowFixMe This error was exposed while converting keyMirror
     * to keyMirrorRecursive */
  ): $Enum<SectionMode> {
  }
}

class X {
  getSectionMode(
    pageMetaData: PageMetaData,
    sectionMetaData: SectionMetaData = ['unknown']
    /* $FlowFixMe This error was exposed while converting keyMirror
     * to keyMirrorRecursive */
  ): $Enum<SectionMode> {
  }
}

class Foo {
  a(lol /*string*/) {}

  b(lol /*string*/
  ) {}

  d(
    lol /*string*/,
    lol2 /*string*/,
    lol3 /*string*/,
    lol4 /*string*/
  ) {}

  d(
    lol /*string*/,
    lol2 /*string*/,
    lol3 /*string*/,
    lol4 /*string*/
  ) /*string*/ {}

  // prettier-ignore
  c(lol /*string*/
  ) {}

  // prettier-ignore
  d(
    lol /*string*/,
    lol2 /*string*/,
    lol3 /*string*/,
    lol4 /*string*/
  ) {}

  // prettier-ignore
  e(
    lol /*string*/,
    lol2 /*string*/,
    lol3 /*string*/,
    lol4 /*string*/
  ) {} /* string*/
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type f = (
  currentRequest: { a: number }
  // TODO this is a very very very very long comment that makes it go > 80 columns
) => number;

f = (
  currentRequest: { a: number }
  // TODO this is a very very very very long comment that makes it go > 80 columns
): number => {};

f = (
  currentRequest: { a: number }
  // TODO this is a very very very very long comment that makes it go > 80 columns
) => {};

f = function(
  currentRequest: { a: number }
  // TODO this is a very very very very long comment that makes it go > 80 columns
) {};

class X {
  f(
    currentRequest: { a: number }
    // TODO this is a very very very very long comment that makes it go > 80 columns
  ) {}
}

function f(
  a: number
  // some comment here
): number {
  return a + 1;
}

var x = {
  getSectionMode(
    pageMetaData: PageMetaData,
    sectionMetaData: SectionMetaData
    /* $FlowFixMe This error was exposed while converting keyMirror
     * to keyMirrorRecursive */
  ): $Enum<SectionMode> {}
};

class X {
  getSectionMode(
    pageMetaData: PageMetaData,
    sectionMetaData: SectionMetaData = ["unknown"]
    /* $FlowFixMe This error was exposed while converting keyMirror
     * to keyMirrorRecursive */
  ): $Enum<SectionMode> {}
}

class Foo {
  a(lol /*string*/) {}

  b(lol /*string*/) {}

  d(lol /*string*/, lol2 /*string*/, lol3 /*string*/, lol4 /*string*/) {}

  d(
    lol /*string*/,
    lol2 /*string*/,
    lol3 /*string*/,
    lol4 /*string*/
  ) /*string*/ {}

  // prettier-ignore
  c(lol /*string*/
  ) {}

  // prettier-ignore
  d(
    lol /*string*/,
    lol2 /*string*/,
    lol3 /*string*/,
    lol4 /*string*/
  ) {}

  // prettier-ignore
  e(
    lol /*string*/,
    lol2 /*string*/,
    lol3 /*string*/,
    lol4 /*string*/
  ) {} /* string*/
}

`;

exports[`preserve-new-line-last.js - flow-verify: preserve-new-line-last.js 1`] = `
function f() {
  a
  /* eslint-disable */
}

function f() {
  a

  /* eslint-disable */
}

function name() {
  // comment1
  func1()

  // comment2
  func2()

  // comment3 why func3 commented
  // func3()
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function f() {
  a;
  /* eslint-disable */
}

function f() {
  a;

  /* eslint-disable */
}

function name() {
  // comment1
  func1();

  // comment2
  func2();

  // comment3 why func3 commented
  // func3()
}

`;

exports[`return-statement.js - flow-verify: return-statement.js 1`] = `
function jsx() {
  return (
    // Comment
    <div />
  );
}

function unary() {
  return (
    // Comment
    !!x
  );
}

function numericLiteralNoParen() {
  return 1337; // Comment
}

function logical() {
  return (
    // Reason for 42
    42
  ) && 84
}

function binary() {
  return (
    // Reason for 42
    42
  ) * 84
}

function binaryInBinaryLeft() {
  return (
    // Reason for 42
    42
  ) * 84 + 2
}

function binaryInBinaryRight() {
  return (
    // Reason for 42
    42
  ) + 84 * 2
}

function conditional() {
  return (
    // Reason for 42
    42
  ) ? 1 : 2
}

function binaryInConditional() {
  return (
    // Reason for 42
    42
  ) * 3 ? 1 : 2
}

function call() {
  return (
    // Reason for a
    a
  )()
}

function memberInside() {
  return (
    // Reason for a.b
    a.b
  ).c
}

function memberOutside() {
  return (
    // Reason for a
    a
  ).b.c
}

function memberInAndOutWithCalls() {
  return (
    // Reason for a
    aFunction.b()
  ).c.d()
}

function excessiveEverything() {
  return (
    // Reason for stuff
    a.b() * 3 + 4 ? (a\`hi\`, 1) ? 1 : 1 : 1
  )
}

// See https://github.com/prettier/prettier/issues/2392
function sequenceExpression() {
  return (
    // Reason for a
    a
  ), b
}

function sequenceExpressionInside() {
  return ( // Reason for a
    a, b
  );
}

function taggedTemplate() {
  return (
    // Reason for a
    a
  )\`b\`
}

function inlineComment() {
  return (
    /* hi */ 42
  ) || 42
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function jsx() {
  return (
    // Comment
    <div />
  );
}

function unary() {
  return (
    // Comment
    !!x
  );
}

function numericLiteralNoParen() {
  return 1337; // Comment
}

function logical() {
  return (
    // Reason for 42
    42 && 84
  );
}

function binary() {
  return (
    // Reason for 42
    42 * 84
  );
}

function binaryInBinaryLeft() {
  return (
    // Reason for 42
    42 *
      84 +
    2
  );
}

function binaryInBinaryRight() {
  return (
    // Reason for 42
    42 +
    84 * 2
  );
}

function conditional() {
  return (
    // Reason for 42
    42
      ? 1
      : 2
  );
}

function binaryInConditional() {
  return (
    // Reason for 42
    42 * 3
      ? 1
      : 2
  );
}

function call() {
  return (
    // Reason for a
    a()
  );
}

function memberInside() {
  return (
    // Reason for a.b
    a.b.c
  );
}

function memberOutside() {
  return (
    // Reason for a
    a.b.c
  );
}

function memberInAndOutWithCalls() {
  return (
    aFunction
      .b// Reason for a
      ()
      .c.d()
  );
}

function excessiveEverything() {
  return (
    // Reason for stuff
    a.b() * 3 + 4 ? ((a\`hi\`, 1) ? 1 : 1) : 1
  );
}

// See https://github.com/prettier/prettier/issues/2392
function sequenceExpression() {
  return (
    // Reason for a
    a, b
  );
}

function sequenceExpressionInside() {
  return (
    // Reason for a
    a, b
  );
}

function taggedTemplate() {
  return (
    // Reason for a
    a\`b\`
  );
}

function inlineComment() {
  return /* hi */ 42 || 42;
}

`;

exports[`switch.js - flow-verify: switch.js 1`] = `
switch (node && node.type) {
  case "Property":
  case "MethodDefinition":
    prop = node.key;
    break;

  case "MemberExpression":
    prop = node.property;
    break;

  // no default
}

switch (foo) {
  case "bar":
    doThing()

  // no default
}

switch (foo) {
  case "bar": //comment
    doThing(); //comment

  case "baz":
    doOtherThing(); //comment

}

switch (foo) {
  case "bar": {
    doThing();
  } //comment

  case "baz": {
    doThing();
  } //comment
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
switch (node && node.type) {
  case "Property":
  case "MethodDefinition":
    prop = node.key;
    break;

  case "MemberExpression":
    prop = node.property;
    break;

  // no default
}

switch (foo) {
  case "bar":
    doThing();

  // no default
}

switch (foo) {
  case "bar": //comment
    doThing(); //comment

  case "baz":
    doOtherThing(); //comment
}

switch (foo) {
  case "bar": {
    doThing();
  } //comment

  case "baz": {
    doThing();
  } //comment
}

`;

exports[`template-literal.js - flow-verify: template-literal.js 1`] = `
\`
\${a // comment
}

\${b /* comment */}

\${/* comment */ c /* comment */}

\${// comment
d //comment
};
\`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\`
\${
  a // comment
}

\${b /* comment */}

\${/* comment */ c /* comment */}

\${
  // comment
  d //comment
};
\`;

`;

exports[`trailing_space.js - flow-verify: trailing_space.js 1`] = `
#!/there/is-space-here->         

// Do not trim trailing whitespace from this source file!

// There is some space here ->                        
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#!/there/is-space-here->

// Do not trim trailing whitespace from this source file!

// There is some space here ->

`;

exports[`trailing-jsdocs.js - flow-verify: trailing-jsdocs.js 1`] = `
const CONNECTION_STATUS = exports.CONNECTION_STATUS = {
  CLOSED: Object.freeze({ kind: 'CLOSED' }),
  CONNECTED: Object.freeze({ kind: 'CONNECTED' }),
  CONNECTING: Object.freeze({ kind: 'CONNECTING' }),
  NOT_CONNECTED: Object.freeze({ kind: 'NOT_CONNECTED' }) };

/* A comment */ /**
* A type that can be written to a buffer.
*/ /**
* Describes the connection status of a ReactiveSocket/DuplexConnection.
* - NOT_CONNECTED: no connection established or pending.
* - CONNECTING: when \`connect()\` has been called but a connection is not yet
*   established.
* - CONNECTED: when a connection is established.
* - CLOSED: when the connection has been explicitly closed via \`close()\`.
* - ERROR: when the connection has been closed for any other reason.
*/ /**
* A contract providing different interaction models per the [ReactiveSocket protocol]
* (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
*/ /**
* A single unit of data exchanged between the peers of a \`ReactiveSocket\`.
*/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const CONNECTION_STATUS = (exports.CONNECTION_STATUS = {
  CLOSED: Object.freeze({ kind: "CLOSED" }),
  CONNECTED: Object.freeze({ kind: "CONNECTED" }),
  CONNECTING: Object.freeze({ kind: "CONNECTING" }),
  NOT_CONNECTED: Object.freeze({ kind: "NOT_CONNECTED" })
});

/* A comment */
/**
 * A type that can be written to a buffer.
 */
/**
 * Describes the connection status of a ReactiveSocket/DuplexConnection.
 * - NOT_CONNECTED: no connection established or pending.
 * - CONNECTING: when \`connect()\` has been called but a connection is not yet
 *   established.
 * - CONNECTED: when a connection is established.
 * - CLOSED: when the connection has been explicitly closed via \`close()\`.
 * - ERROR: when the connection has been closed for any other reason.
 */
/**
 * A contract providing different interaction models per the [ReactiveSocket protocol]
 * (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
 */
/**
 * A single unit of data exchanged between the peers of a \`ReactiveSocket\`.
 */

`;

exports[`try.js - flow-verify: try.js 1`] = `
// comment 1
try {
  // comment 2
}
// comment 3
catch(e) {
  // comment 4
}
// comment 5
finally // comment 6
{
  // comment 7
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// comment 1
try {
  // comment 2
} catch (e) {
  // comment 3
  // comment 4
} finally { // comment 6
  // comment 5
  // comment 7
}

`;

exports[`variable_declarator.js - flow-verify: variable_declarator.js 1`] = `
let obj = // Comment
{
  key: 'val'
}

let obj // Comment
= {
  key: 'val'
}

let obj = { // Comment
  key: 'val'
}

let obj = {
  // Comment
  key: 'val'
}

let obj = // Comment
[
  'val'
]

let obj // Comment
= [
  'val'
]

let obj = [ // Comment
  'val'
]

let obj = [
  // Comment
  'val'
]

let obj = // Comment
\`val\`;

let obj = // Comment
\`
val
val
\`;

let obj = // Comment
tag\`val\`;

let obj = // Comment
tag\`
val
val
\`;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let obj =
  // Comment
  {
    key: "val"
  };

let obj =
  // Comment
  {
    key: "val"
  };

let obj = {
  // Comment
  key: "val"
};

let obj = {
  // Comment
  key: "val"
};

let obj =
  // Comment
  ["val"];

let obj =
  // Comment
  ["val"];

let obj = [
  // Comment
  "val"
];

let obj = [
  // Comment
  "val"
];

let obj =
  // Comment
  \`val\`;

let obj =
  // Comment
  \`
val
val
\`;

let obj =
  // Comment
  tag\`val\`;

let obj =
  // Comment
  tag\`
val
val
\`;

`;
